<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Path Editor</title>
  <style>
    body { margin: 0; overflow: hidden; } /* Prevent scrolling on the page */
    canvas { display: block; }
    .arrow-overlay {
      position: absolute;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TransformControls.js"></script>
  <script>
    // Setup scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    const initialCameraPosition = new THREE.Vector3(0, 10, 10);
    const initialCameraLookAt = new THREE.Vector3(0, 0, 0);
    camera.position.copy(initialCameraPosition);
    camera.lookAt(initialCameraLookAt);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xffffff); // Set renderer background color to white
    document.body.appendChild(renderer.domElement);

    // Add 3D axes
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Add grid
    const gridHelper = new THREE.GridHelper(10, 10);
    scene.add(gridHelper);

    // Declare selectedObject variable

    const controlPoints = [];
    const numControlPoints = 5;
    const gridBounds = 2; // Define bounds of the grid
    // Load OBJ model
    const loader = new THREE.OBJLoader();
    const promises = [];
    for (let i = 0; i < numControlPoints; i++) {
      const x = -2 * gridBounds + (i / (numControlPoints - 1)) * gridBounds * 4; // Linearly spaced along X-axis
      const y = 2; // Line on Y=0 plane
      const z = 0; // Line on Z=0 plane
      const promise = new Promise((resolve, reject) => {
        loader.load(
         'http://0.0.0.0:8080/robotiq.obj',
          function (obj) {
            obj.traverse(function (child) {
              if (child instanceof THREE.Mesh) {
                // Set position of the loaded mesh
                child.scale.set(5, 5, 5);
                child.geometry.computeBoundingSphere();
                child.geometry.computeBoundingBox();
                child.position.set(x, y, z);
                // Add the loaded mesh to the scene
                scene.add(child);
                // Push the loaded mesh to the controlPoints array
                controlPoints.push(child);
                // Resolve the promise once the OBJ model is loaded and added to the scene
                resolve();
              }
            });
          },
          undefined,
          reject
        );
      });
      promises.push(promise);
    }


    let curve;
    let points;
    let path;
    // Wait for all promises to resolve before creating the path curve
    Promise.all(promises).then(() => {
      // Create path curve
      //const curve = new THREE.CatmullRomCurve3(controlPoints.map(point => point.position));
      //const points = curve.getPoints(50);
      curve = new THREE.CatmullRomCurve3(controlPoints.map(point => point.position));
      points = curve.getPoints(50);
      //console.log("Control points:", controlPoints);
      //console.log("Control points positions:", controlPoints.map(point => point.position));
      console.log("Points for path curve:", points);
      // Continue with your code using the `points` array

      // Create path geometry
      const pathGeometry = new THREE.BufferGeometry().setFromPoints(points);
      // Create path material
      const pathMaterial = new THREE.LineBasicMaterial({ color: 0xffa500 }); // Orange color
      // Create path line
      //const path = new THREE.Line(pathGeometry, pathMaterial);
      path = new THREE.Line(pathGeometry, pathMaterial);
      // Add path line to the scene
      scene.add(path);
    });

    // Generate random colors for point cloud
    const numPoints = 2000;
    const pointCloudGeometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    for (let i = 0; i < numPoints; i++) {
      const x = Math.random() * gridBounds * 2 - gridBounds;
      const y = Math.random() * gridBounds * 2;
      const z = Math.random() * gridBounds * 2 - gridBounds;
      positions.push(x, y, z);

      const color = new THREE.Color(Math.random(), Math.random(), Math.random()); // Generate random color
      colors.push(color.r, color.g, color.b);
    }
    pointCloudGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    pointCloudGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); // Set colors attribute
    const pointCloudMaterial = new THREE.PointsMaterial({
        size: 0.15, // Adjust the size of the points
        opacity: 0.35,
        vertexColors: true, // Enable vertex colors
        transparent: true
    });
    const pointCloud = new THREE.Points(pointCloudGeometry, pointCloudMaterial);
    scene.add(pointCloud);

    // Event listener for mouse interaction
    document.addEventListener('mousedown', onMouseDown, false);
    document.addEventListener('mouseup', onMouseUp, false);
    document.addEventListener('mousemove', onMouseMove, false);
    document.addEventListener('wheel', onWheel, { passive: false });
    //document.addEventListener('wheel', onWheel, false);
    document.addEventListener('keydown', onKeyDown, false);

    // Boolean to track mouse button state
    let isMouseDown = false;
    let selectedObject = null;
    let transformControl = null;
    let originalControl = null;

    // Arrow Helper for showing direction
    const arrowRadius = 0.6;
    const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 0), new THREE.Vector3(), 1.3, 0xFFA500, arrowRadius);
    arrowHelper.visible = false; // Initially hidden
    scene.add(arrowHelper);

    //// Event handler for mouse down
    function onMouseDown(event) {
      event.preventDefault();
      isMouseDown = true;
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.near = 0.1;
      raycaster.far = 30;
      raycaster.setFromCamera(mouse, camera);
      // Filter out axesHelper and gridHelper from the intersects array
      const intersects = raycaster.intersectObjects(scene.children.filter(obj => obj !== axesHelper && obj !== gridHelper && obj != path && obj != pointCloud), true);
      
      if (intersects.length > 0) {
        const intersect = intersects[0];
        selectedObject = intersect.object;
      }
    }

    // Event handler for mouse up
    function onMouseUp(event) {
      event.preventDefault();
      isMouseDown = false;
    }

    // Boolean to track key state
    let keys = {
      x: false,
      y: false,
      z: false
    };
    
    // Event listener for key down
    document.addEventListener('keydown', function(event) {
      keys[event.key.toLowerCase()] = true;
      if (event.key === '0') {
        resetCamera();
      }
    });
    
    // Event listener for key up
    document.addEventListener('keyup', function(event) {
      keys[event.key.toLowerCase()] = false;
      arrowHelper.visible = false; // Hide arrow when key is released
    });

    // Event handler for mouse move
    function onMouseMove(event) {
      event.preventDefault();
      if (isMouseDown && selectedObject && !transformControl && !originalControl && selectedObject.position) {
        const movementX = event.movementX;
        const movementY = event.movementY;
        const index = controlPoints.indexOf(selectedObject);
        const point = controlPoints[index].position;
    
        // Adjust the movement vector based on keys pressed
        const mv = new THREE.Vector3(movementX, -movementY, 0.5*(movementX+movementY));
        console.log(mv);
        if (keys['x']) {
          mv.y = 0; // Lock movement on Y-axis
          mv.z = 0; // Lock movement on Z-axis
          arrowHelper.setDirection(new THREE.Vector3(mv.x, 0, 0)); // Set arrow direction along X-axis
          arrowHelper.visible = !(mv.x === 0 && mv.y === 0 && mv.z === 0); // Show arrow
          //arrowHelper.visible = true; // Show arrow
        } else if (keys['z']) {
          mv.x = 0; // Lock movement on X-axis
          mv.z = 0; // Lock movement on Z-axis
          arrowHelper.setDirection(new THREE.Vector3(0, mv.y, 0)); // Set arrow direction along Z-axis
          arrowHelper.visible = !(mv.x === 0 && mv.y === 0 && mv.z === 0); // Show arrow
          //arrowHelper.visible = true; // Show arrow
        } else if (keys['y']) {
          mv.x = 0; // Lock movement on X-axis
          mv.y = 0; // Lock movement on Y-axis
          arrowHelper.setDirection(new THREE.Vector3(0, 0, mv.z)); // Set arrow direction along Y-axis
          arrowHelper.visible = !(mv.x === 0 && mv.y === 0 && mv.z === 0); // Show arrow
          //arrowHelper.visible = true; // Show arrow
        } else {
          arrowHelper.setDirection(new THREE.Vector3(0, 0, 0)); // Set arrow direction along Y-axis
          arrowHelper.visible = false; // Show arrow
        } 
        arrowHelper.position.copy(point);
    
        // Convert movement vector to 3D space
        point.add(mv.multiplyScalar(0.015)); // Scale the movement and apply to the point
    
        // Update the curve and path
        curve.points[index].copy(point);
        const updatedPoints = curve.getPoints(50);
        path.geometry.setFromPoints(updatedPoints);
      } 
    }


    // Event handler for mouse wheel (trackpad) rotation
    function onWheel(event) {
      event.preventDefault();
      // Adjust camera rotation based on wheel movement along the X and Z axes
      const movementX = event.deltaX * 0.0006;
      const movementZ = event.deltaY * 0.0006;
      const newPosition = new THREE.Vector3().copy(camera.position);
      newPosition.applyAxisAngle(new THREE.Vector3(1, 0, 0), movementZ); // Rotate around Z-axis
      newPosition.applyAxisAngle(new THREE.Vector3(0, 1, 0), movementX); // Rotate around Z-axis
      camera.position.copy(newPosition);
      camera.lookAt(0, 0, 0); // Maintain lookAt position
    }

    // Event handler for key down
    function onKeyDown(event) {
      if (event.key === 'r') {
        event.preventDefault();
        if (selectedObject && !transformControl && !originalControl) {
          originalControl = selectedObject.clone(); // Store original object
          transformControl = new THREE.TransformControls(camera, renderer.domElement);
          transformControl.setSize(0.75);
          transformControl.attach(selectedObject);
          transformControl.setMode("rotate"); // Set mode to rotate
          scene.add(transformControl);
          transformControl.setTranslationSnap(0); // Disable translation snap
        }
      } else if (event.key === 'Escape') {
        event.preventDefault();
        if (transformControl) {
          scene.remove(transformControl);
          transformControl.detach();
          transformControl.dispose();
          transformControl = null;
          originalControl = null;
        }
      } else if (event.key === 'c') {
        event.preventDefault();
        if (selectedObject && originalControl) {
          selectedObject.rotation.copy(originalControl.rotation);
          if (transformControl) {
            transformControl.setMode("rotate"); // Set mode to rotate
          }
        }
      }
    }

    // Function to reset the camera to its initial pose
    function resetCamera() {
      camera.position.copy(initialCameraPosition);
      camera.lookAt(initialCameraLookAt);
    }

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
      if (transformControl !== null) {
        transformControl.update();
      }
    }
    animate();
  </script>
</body>
</html>

