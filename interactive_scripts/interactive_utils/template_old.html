<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Object Manipulation</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: white; } /* Set background color to white */
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/TransformControls.js"></script>
  <script>
    // Setup scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    const initialCameraPosition = new THREE.Vector3(0, 10, 10);
    const initialCameraLookAt = new THREE.Vector3(0, 0, 0);
    camera.position.copy(initialCameraPosition);
    camera.lookAt(initialCameraLookAt);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xffffff); // Set background color to white
    document.body.appendChild(renderer.domElement);

    // Add 3D axes
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    // Declare selectedObject variable
    let selectedObject = null;
    let transformControl = null;
    let originalControl = null;
    let isTranslationMode = true;
    let isMouseDown = false;
    let url = 'http://localhost:8080/robotiq_closed.obj';

    // Arrow Helper for showing direction
    const arrowRadius = 0.6;
    const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 0), new THREE.Vector3(), 1.3, 0xFFA500, arrowRadius);
    arrowHelper.visible = false; // Initially hidden
    scene.add(arrowHelper);

    // Function to add object to scene
    function addObject(obj) {
      selectedObject = obj;
      scene.add(selectedObject);
    }
    document.addEventListener('mousemove', onMouseMove);

    // Generate random colors for point cloud
    const positions = %s
    const colors = %s
    const pointCloudGeometry = new THREE.BufferGeometry();
    pointCloudGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    pointCloudGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); // Set colors attribute
    const pointCloudMaterial = new THREE.PointsMaterial({
        size: 0.15, // Adjust the size of the points
        opacity: 0.35,
        vertexColors: true, // Enable vertex colors
        transparent: true
    });
    const pointCloud = new THREE.Points(pointCloudGeometry, pointCloudMaterial);
    scene.add(pointCloud);

    // Function to load object
    function loadObject(url, position, rotation, index) {
      const loader = new THREE.OBJLoader();
      loader.load(
        url,
        function (obj) {
          obj.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
              child.scale.set(5, 5, 5);
              child.geometry.computeBoundingSphere();
              child.geometry.computeBoundingBox();
              child.position.copy(position); // Set object position
              child.quaternion.setFromEuler(rotation);
              addObject(child.clone(), index);
            }
          });
        },
        undefined,
        function (error) {
          console.error('Error loading object:', error);
        }
      );
    }

    //const initialPos = new THREE.Vector3(0, 1, 0);
    const initialPos = %s;
    const initialRot = %s;
    //loadObject(url, initialPos, new THREE.Euler(0, 0, 0), -1);
    loadObject(url, initialPos, initialRot, -1);

    // Event handler for mouse move
    function onMouseMove(event) {
      event.preventDefault();
      if (isMouseDown && selectedObject && isTranslationMode) {
        const movementX = event.movementX;
        const movementY = event.movementY;
    
        // Adjust the movement vector based on keys pressed
        const mv = new THREE.Vector3(movementX, -movementY, 0.5*(movementX+movementY));
        if (keys['x']) {
          mv.y = 0; // Lock movement on Y-axis
          mv.z = 0; // Lock movement on Z-axis
          arrowHelper.setDirection(new THREE.Vector3(mv.x, 0, 0)); // Set arrow direction along X-axis
          arrowHelper.visible = !(mv.x === 0 && mv.y === 0 && mv.z === 0); // Show arrow
          //arrowHelper.visible = true; // Show arrow
        } else if (keys['z']) {
          mv.x = 0; // Lock movement on X-axis
          mv.z = 0; // Lock movement on Z-axis
          arrowHelper.setDirection(new THREE.Vector3(0, mv.y, 0)); // Set arrow direction along Z-axis
          arrowHelper.visible = !(mv.x === 0 && mv.y === 0 && mv.z === 0); // Show arrow
          //arrowHelper.visible = true; // Show arrow
        } else if (keys['y']) {
          mv.x = 0; // Lock movement on X-axis
          mv.y = 0; // Lock movement on Y-axis
          arrowHelper.setDirection(new THREE.Vector3(0, 0, mv.z)); // Set arrow direction along Y-axis
          arrowHelper.visible = !(mv.x === 0 && mv.y === 0 && mv.z === 0); // Show arrow
          //arrowHelper.visible = true; // Show arrow
        } else {
          arrowHelper.setDirection(new THREE.Vector3(0, 0, 0)); // Set arrow direction along Y-axis
          arrowHelper.visible = false; // Show arrow
        } 
        arrowHelper.position.copy(selectedObject.position);
        const point = selectedObject.position.clone();
        point.add(mv.multiplyScalar(0.003)); // Scale the movement and apply to the point
        selectedObject.position.copy(point); // Scale the movement and apply to the point
    
      }
    }

    // Event listener for mouse down
    document.addEventListener('mousedown', function(event) {
      isMouseDown = true;
    });

    // Event listener for mouse up
    document.addEventListener('mouseup', function(event) {
      isMouseDown = false;
    });

    // Boolean to track key state
    let keys = {
      x: false,
      y: false,
      z: false
    };


    // Event listener for key up
    document.addEventListener('keyup', function(event) {
      keys[event.key.toLowerCase()] = false;
      arrowHelper.visible = false; // Hide arrow when key is released
    });

    // Establish WebSocket connection to the server
    const socket = new WebSocket('ws://localhost:8765');

    // Function to send position and orientation data of the selectedObject to the server
    function sendPositionAndOrientation(selectedObject) {
      // Check if the selectedObject is not null
      if (selectedObject) {
        // Check if the WebSocket connection is open
        if (socket.readyState === WebSocket.OPEN) {
          // Get position and orientation of the selectedObject
          const position = selectedObject.position;
          const orientation = selectedObject.rotation;

          // Create data object
          const data = {
            position: {
              x: position.x,
              y: position.y,
              z: position.z
            },
            orientation: {
              x: orientation.x,
              y: orientation.y,
              z: orientation.z
            },
            url
          };

          // Send data over the WebSocket connection
          socket.send(JSON.stringify(data));
        } else {
          console.error('WebSocket connection is not open');
        }
      } else {
        console.log('No object selected');
      }
    }

    // Add an event listener to handle WebSocket connection opening
    socket.addEventListener('open', function (event) {
      console.log('WebSocket connection opened');

      // Start sending position and orientation data of the selectedObject continuously
      setInterval(function () {
        // Replace selectedObject with your actual selected object
        sendPositionAndOrientation(selectedObject);
      }, 1); // Send data every 1000 milliseconds (1 second)
    });


    // Event listener for key down
    document.addEventListener('keydown', function(event) {
      keys[event.key.toLowerCase()] = true;
      if (event.key === 'r') {
        event.preventDefault();
        if (selectedObject && isTranslationMode) {
          isTranslationMode = false;
          document.removeEventListener('mousemove', onMouseMove);
          originalControl = selectedObject.clone();
          transformControl = new THREE.TransformControls(camera, renderer.domElement);
          transformControl.setSize(0.75);
          transformControl.attach(selectedObject);
          transformControl.setMode("rotate");
          scene.add(transformControl);
          transformControl.setTranslationSnap(0);
          // Listen for the change event on transformControl
          transformControl.addEventListener('change', function() {
              selectedObject.rotation.copy(selectedObject.rotation);
          });
        }
      } else if (event.key === 'Escape') {
        event.preventDefault();
        if (transformControl) {
          isTranslationMode = true;
          scene.remove(transformControl);
          transformControl.detach();
          transformControl.dispose();
          transformControl = null;
          originalControl = null;
          document.addEventListener('mousemove', onMouseMove);
        }
      } else if (event.key === 'g') {
        console.log("in g");
        event.preventDefault();
        if (selectedObject) {
          let newUrl = '';
          // Store position and rotation of selectedObject
          const position = selectedObject.position.clone();
          const rotation = selectedObject.rotation.clone();
          console.log(rotation);
          if (url === 'http://localhost:8080/robotiq_closed.obj') {
            console.log("Loading OPEN mesh");
            newUrl = 'http://localhost:8080/robotiq.obj';
          } else if (url === 'http://localhost:8080/robotiq.obj') {
            console.log("Loading CLOSED mesh");
            newUrl = 'http://localhost:8080/robotiq_closed.obj';
          }
          scene.remove(selectedObject);
          loadObject(newUrl, position, rotation, -1);
          url = newUrl;
        }
      } else if (keys['f'] || keys['b']) {
        // Determine the direction
        const direction = keys['f'] ? -2 : 2;
        // Calculate the movement speed based on key press duration
        const movementSpeed = direction * Math.min((performance.now() - keyPressStartTime) * 0.0002, 0.03);
        // Move relative to selectedObject's rotation
        const point = selectedObject.position;
        const movementVector = new THREE.Vector3(0, movementSpeed, 0);
        movementVector.applyQuaternion(selectedObject.quaternion);
        point.add(movementVector);
        selectedObject.position.copy(point);
      }
    });

    // Variable to track key press start time
    let keyPressStartTime = 0;

    // Event listener for key down
    document.addEventListener('keydown', function(event) {
      keys[event.key.toLowerCase()] = true;
      // Record the start time of key press
      keyPressStartTime = performance.now();
    });

    // Event listener for key up
    document.addEventListener('keyup', function(event) {
      keys[event.key.toLowerCase()] = false;
      arrowHelper.visible = false; // Hide arrow when key is released
    });

    // Event handler for mouse wheel (trackpad) rotation
    function onWheel(event) {
      event.preventDefault();
      // Adjust camera rotation based on wheel movement along the X and Z axes
      const movementX = event.deltaX * 0.0006;
      const movementZ = event.deltaY * 0.0006;
      const newPosition = new THREE.Vector3().copy(camera.position);
      newPosition.applyAxisAngle(new THREE.Vector3(1, 0, 0), movementZ); // Rotate around Z-axis
      newPosition.applyAxisAngle(new THREE.Vector3(0, 1, 0), movementX); // Rotate around Z-axis
      camera.position.copy(newPosition);
      camera.lookAt(initialCameraLookAt); // Maintain lookAt position
    }    

    // Event listener for wheel event
    document.addEventListener('wheel', onWheel, { passive: false });

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>

